<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ATREYUETECH@Plexity - Quantum Fractal Resonance Engine</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script src="https://threejs.org/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://threejs.org/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://threejs.org/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://threejs.org/examples/js/shaders/CopyShader.js"></script>
<script src="https://threejs.org/examples/js/shaders/LuminosityHighPassShader.js"></script>

<!-- Vertex Shader for Nodes -->
<script id="nodeVertexShader" type="x-shader/x-vertex">
  uniform float time;
  uniform float audioEnergy;
  varying vec3 vNormal;

  float noise(vec3 p) {
    return sin(p.x * 2.0 + time * 0.5) * cos(p.y * 3.0) * sin(p.z * 4.0);
  }

  void main() {
    vNormal = normalize(normalMatrix * normal);
    float displacement = noise(position * 2.0 + time * 0.5) * 0.2 * audioEnergy;
    vec3 displacedPosition = position + normal * displacement;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(displacedPosition, 1.0);
  }
</script>

<!-- Fragment Shader for Nodes -->
<script id="nodeFragmentShader" type="x-shader/x-fragment">
  uniform vec3 color;
  uniform float audioEnergy;
  varying vec3 vNormal;

  void main() {
    float intensity = 1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0));
    intensity = pow(intensity, 4.0);
    vec3 finalColor = color * (0.8 + audioEnergy * 1.5) + vec3(0.8, 0.9, 1.0) * intensity;
    gl_FragColor = vec4(finalColor * 2.5, 1.0);
  }
</script>

<!-- Vertex Shader for Connections -->
<script id="lineVertexShader" type="x-shader/x-vertex">
  varying float vDistance;
  void main() {
    vDistance = gl_Position.z;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
</script>

<!-- Fragment Shader for Connections -->
<script id="lineFragmentShader" type="x-shader/x-fragment">
  uniform float time;
  uniform vec3 color1;
  uniform vec3 color2;
  uniform float entangleStrength;
  uniform float opacityValue;
  varying float vDistance;

  void main() {
    float wave = sin(vDistance * 40.0 + time * 8.0 * entangleStrength);
    float glow = pow(abs(wave), 8.0) * 0.5;
    vec3 finalColor = mix(color1, color2, glow);
    float finalOpacity = opacityValue + glow * 0.5;
    gl_FragColor = vec4(finalColor * 3.0, finalOpacity);
  }
</script>

<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    background: radial-gradient(circle at center, #050f19 0%, #000000 85%);
    font-family: 'Courier New', monospace;
    color: #40e0d0;
    user-select: none;
  }
  #canvas3d {
    position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
    display: block;
    cursor: crosshair;
  }
  #ui-overlay {
    position: fixed; top: 15px; left: 15px; right: 15px; z-index: 9999;
    display: flex; flex-wrap: wrap; gap: 10px;
    background: rgba(5,15,25,0.85);
    border-radius: 12px;
    padding: 12px;
    box-shadow: 0 0 25px rgba(64, 224, 208, 0.5);
    max-width: calc(100vw - 30px);
  }
  button.control-btn, label.input-label {
    background: linear-gradient(135deg, #004466 0%, #006688 100%);
    border: 1px solid #40e0d0;
    color: #e0f8ff;
    padding: 10px 16px;
    border-radius: 15px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.25s ease;
    user-select: none;
  }
  button.control-btn:hover, label.input-label:hover {
    background: linear-gradient(135deg, #40e0d0 0%, #20b2aa 100%);
    color: #000000;
    box-shadow: 0 0 16px #40e0d0;
  }
  input[type=range] {
    -webkit-appearance: none;
    width: 120px;
    height: 6px;
    margin-top: 4px;
    background: linear-gradient(90deg, #001122 0%, #003344 100%);
    border-radius: 8px;
    outline: none;
    cursor: pointer;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    background: #40e0d0;
    border-radius: 50%;
    box-shadow: 0 0 12px #40e0d0;
  }
  #status-display {
    position: fixed; bottom: 15px; left: 15px; z-index: 9999;
    background: rgba(5, 15, 25, 0.85);
    padding: 8px 12px; border-radius: 10px; border: 1px solid #40e0d0;
    font-size: 0.8em; pointer-events: none;
  }
</style>
</head>
<body>

<canvas id="canvas3d"></canvas>

<div id="ui-overlay" aria-label="Control panel">
  <button id="btnToggleAnimation" class="control-btn" aria-pressed="true" aria-label="Toggle animation">Pause Animation</button>
  <button id="btnRegenerate" class="control-btn" aria-label="Regenerate lattice">Regenerate Lattice</button>

  <label class="input-label" for="fractalDepthRange">Fractal Depth
    <input type="range" id="fractalDepthRange" min="1" max="6" step="1" value="3" aria-valuemin="1" aria-valuemax="6" aria-valuenow="3" aria-label="Fractal Depth Slider"/>
  </label>

  <label class="input-label" for="entangleStrengthRange">Entanglement Strength
    <input type="range" id="entangleStrengthRange" min="0.5" max="5" step="0.1" value="1.5" aria-valuemin="0.5" aria-valuemax="5" aria-valuenow="1.5" aria-label="Entanglement Strength Slider"/>
  </label>

  <button id="btnToggleAudio" class="control-btn" aria-pressed="false" aria-label="Toggle audio">Start Audio (Test)</button>
</div>

<div id="status-display">
    Status: <span id="currentStatus">Initializing...</span> | Audio Energy: <span id="energyDisplay">0.50</span>
</div>

<script>
  // GLOBALS
  let scene, camera, renderer, composer;
  let latticeGroup;
  let latticePoints = [];
  let connections = [];
  let isAnimating = true;
  let time = 0;
  let globalAudioEnergy = 0.5; // base energy

  // Web Audio Setup
  let audioContext = null;
  let analyser, freqDataArray;
  let oscillator = null;

  // UI Elements
  const fractalDepthControl = document.getElementById('fractalDepthRange');
  const entangleStrengthControl = document.getElementById('entangleStrengthRange');
  const statusDisplay = document.getElementById('currentStatus');
  const energyDisplay = document.getElementById('energyDisplay');

  const themes = {
      bg: 0x050f19,
      primary: 0x1a5276,
      secondary: 0x145a32,
      accent: 0x40e0d0,
      glow: 0x8ae2ff,
  };

  // Node Creation with ShaderMaterial
  function createNode(x, y, z, depth, index) {
      const geometry = new THREE.SphereGeometry(0.12, 16, 16);
      const material = new THREE.ShaderMaterial({
          uniforms: {
              time: { value: 0.0 },
              audioEnergy: { value: 0.5 },
              color: { value: new THREE.Color(themes.accent) }
          },
          vertexShader: document.getElementById('nodeVertexShader').textContent,
          fragmentShader: document.getElementById('nodeFragmentShader').textContent,
          transparent: true,
          blending: THREE.AdditiveBlending,
      });

      const node = new THREE.Mesh(geometry, material);
      node.position.set(x, y, z);
      node.userData = { depth, index, energy: 1.0, spin: Math.random() * Math.PI * 2 };
      latticeGroup.add(node);
      latticePoints.push(node);
  }

  // Recursive fractal plexus generator
  function generateFractalPlexus(center, radius, depth) {
      if (depth <= 0) return;
      const count = 6 + depth;
      for (let i = 0; i < count; i++) {
          const angle = (i / count) * Math.PI * 2;
          const x = center.x + Math.cos(angle) * radius;
          const y = center.y + Math.sin(angle) * radius;
          const z = center.z + Math.cos(angle + depth) * 0.1 * radius;
          if (latticePoints.length < 500) {
              createNode(x, y, z, depth, latticePoints.length);
          }
          generateFractalPlexus(new THREE.Vector3(x, y, z), radius * 0.4, depth - 1);
      }
  }

  function clearLattice() {
      while(latticeGroup.children.length > 0) latticeGroup.remove(latticeGroup.children[0]);
      latticePoints.length = 0;
      connections.length = 0;
  }

  // Connections with shader lines and pulse glow
  function createConnections(strength) {
      connections.forEach(conn => latticeGroup.remove(conn));
      connections.length = 0;
      for (let i = 0; i < latticePoints.length; i++) {
          for (let j = i + 1; j < latticePoints.length; j++) {
              const dist = latticePoints[i].position.distanceTo(latticePoints[j].position);
              if (dist < strength * 0.8 + 1.2) {
                  const opacityValue = THREE.MathUtils.clamp(0.1 + (0.5 / dist), 0.1, 0.8);
                  const geom = new THREE.BufferGeometry().setFromPoints([ latticePoints[i].position, latticePoints[j].position ]);
                  
                  const material = new THREE.ShaderMaterial({
                      uniforms: {
                          time: { value: 0.0 },
                          color1: { value: new THREE.Color(themes.secondary) },
                          color2: { value: new THREE.Color(themes.accent) },
                          entangleStrength: { value: strength },
                          opacityValue: { value: opacityValue }
                      },
                      vertexShader: document.getElementById('lineVertexShader').textContent,
                      fragmentShader: document.getElementById('lineFragmentShader').textContent,
                      transparent: true,
                      blending: THREE.AdditiveBlending,
                  });

                  const line = new THREE.Line(geom, material);
                  latticeGroup.add(line);
                  connections.push(line);
              }
          }
      }
  }

  function regenerate() {
      clearLattice();
      const depth = parseInt(fractalDepthControl.value);
      const strength = parseFloat(entangleStrengthControl.value);
      generateFractalPlexus(new THREE.Vector3(0, 0, 0), 3.5, depth);
      createConnections(strength);
      updateStatus(`Lattice Generated: Nodes=${latticePoints.length}`);
  }

  // Audio Setup + Toggle
  function setupAudio() {
      if (audioContext && audioContext.state === 'running') return;
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 256;
      freqDataArray = new Uint8Array(analyser.frequencyBinCount);

      oscillator = audioContext.createOscillator();
      oscillator.type = 'sine';
      oscillator.frequency.setValueAtTime(80, audioContext.currentTime);

      oscillator.connect(analyser);
      analyser.connect(audioContext.destination);
      oscillator.start();

      document.getElementById('btnToggleAudio').textContent = 'Stop Audio (Test)';
      updateStatus('Audio running.');
  }
  function toggleAudio() {
      if (oscillator) {
          oscillator.stop();
          oscillator.disconnect();
          oscillator = null;
          audioContext.close();
          audioContext = null;
          document.getElementById('btnToggleAudio').textContent = 'Start Audio (Test)';
          globalAudioEnergy = 0.5;
          updateStatus('Audio stopped.');
      } else {
          setupAudio();
      }
  }

  // UI & Updates
  function updateStatus(message) {
      statusDisplay.textContent = message;
  }

  function setupControls() {
      document.getElementById('btnToggleAnimation').onclick = () => {
          isAnimating = !isAnimating;
          document.getElementById('btnToggleAnimation').textContent = isAnimating ? 'Pause Animation' : 'Play Animation';
      };
      document.getElementById('btnRegenerate').onclick = regenerate;
      document.getElementById('btnToggleAudio').onclick = toggleAudio;
      fractalDepthControl.oninput = regenerate;
      entangleStrengthControl.oninput = () => createConnections(parseFloat(entangleStrengthControl.value));
  }

  // Initialize Three.js, postprocessing, and start animation loop
  function initThreeJS() {
      const canvas = document.getElementById('canvas3d');
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 50);
      camera.position.z = 10;

      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(themes.bg, 1);

      latticeGroup = new THREE.Group();
      scene.add(latticeGroup);

      const renderScene = new THREE.RenderPass(scene, camera);
      const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.8, 0.5, 0.85);

      composer = new THREE.EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);

      setupControls();
      regenerate();
      window.addEventListener('resize', onResize);
      updateStatus('ATREYUETECH Plexus Initialized. Ready for Creation.');

      animateLoop();
  }

  function onResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
  }

  function animateLoop(timestamp) {
      requestAnimationFrame(animateLoop);
      const delta = timestamp ? (timestamp - (animateLoop._last || timestamp)) / 1000 : 0.016;
      animateLoop._last = timestamp;

      if (isAnimating) {
          time += delta;

          if (analyser && audioContext && audioContext.state === 'running') {
              analyser.getByteFrequencyData(freqDataArray);
              let sum = 0;
              for(let i = 0; i < 30; i++) sum += freqDataArray[i];
              const energyFactor = (sum / 30) / 255;
              globalAudioEnergy = THREE.MathUtils.lerp(0.5, 1.5, energyFactor);
          }
          energyDisplay.textContent = globalAudioEnergy.toFixed(2);

          latticeGroup.rotation.y += delta * 0.15 * globalAudioEnergy;

          latticePoints.forEach(node => {
              node.material.uniforms.time.value = time;
              node.material.uniforms.audioEnergy.value = globalAudioEnergy;
          });

          connections.forEach(line => {
              line.material.uniforms.time.value = time;
              line.material.uniforms.entangleStrength.value = entangleStrengthControl.value;
          });
      }
      composer.render();
  }

  initThreeJS();
</script>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ATREYUETECH@Plexity - Quantum Fractal Resonance Engine</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://threejs.org/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://threejs.org/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://threejs.org/examples/js/postprocessing/UnrealBloomPass.js"></script>

<!-- Enhanced Shaders -->
<script id="nodeVertexShader" type="x-shader/x-vertex">
uniform float time;
uniform float audioEnergy;
uniform float resonance;
varying vec3 vNormal;
varying vec3 vPosition;

float hash(vec3 p) {
    p = fract(p * 0.3183099 + 0.1);
    p *= 17.0;
    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
}

float noise(vec3 x) {
    vec3 i = floor(x);
    vec3 f = fract(x);
    f = f * f * (3.0 - 2.0 * f);
    
    return mix(mix(mix(hash(i + vec3(0,0,0)), 
                      hash(i + vec3(1,0,0)), f.x),
                 mix(hash(i + vec3(0,1,0)), 
                     hash(i + vec3(1,1,0)), f.x), f.y),
            mix(mix(hash(i + vec3(0,0,1)), 
                    hash(i + vec3(1,0,1)), f.x),
               mix(hash(i + vec3(0,1,1)), 
                   hash(i + vec3(1,1,1)), f.x), f.y), f.z);
}

void main() {
    vNormal = normalize(normalMatrix * normal);
    vPosition = position;
    
    // Sacred geometry displacement
    float sacredWave = sin(position.x * 3.14159 + time * resonance) * 
                      cos(position.y * 3.14159 + time * resonance) *
                      sin(position.z * 3.14159 + time * resonance);
    
    float noiseDisplace = noise(position * 2.0 + time * 0.5) * 0.3;
    float energyDisplace = audioEnergy * 0.4;
    
    vec3 displacedPosition = position + normal * (sacredWave * 0.15 + noiseDisplace + energyDisplace);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(displacedPosition, 1.0);
}
</script>

<script id="nodeFragmentShader" type="x-shader/x-fragment">
uniform vec3 color;
uniform float audioEnergy;
uniform float resonance;
varying vec3 vNormal;
varying vec3 vPosition;

void main() {
    // Quantum glow effect
    float intensity = 1.05 - dot(vNormal, vec3(0.0, 0.0, 1.0));
    intensity = pow(intensity, 3.0 + audioEnergy);
    
    // Sacred frequency pulsation
    float pulse = sin(resonance * 10.0) * 0.5 + 0.5;
    
    vec3 glowColor = mix(color, vec3(0.9, 1.0, 1.0), pulse * 0.7);
    vec3 finalColor = glowColor * (0.8 + audioEnergy * 2.0) + vec3(0.8, 0.9, 1.0) * intensity;
    
    gl_FragColor = vec4(finalColor * (1.2 + pulse * 0.8), 1.0);
}
</script>

<script id="lineVertexShader" type="x-shader/x-vertex">
uniform float time;
uniform float entangleStrength;
varying float vDistance;
varying vec3 vPosition;

void main() {
    vPosition = position;
    vDistance = length(position);
    
    // Quantum entanglement wave
    float wave = sin(vDistance * 8.0 + time * entangleStrength * 2.0) * 0.1;
    vec3 waveOffset = normal * wave;
    
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position + waveOffset, 1.0);
}
</script>

<script id="lineFragmentShader" type="x-shader/x-fragment">
uniform float time;
uniform vec3 color1;
uniform vec3 color2;
uniform float entangleStrength;
uniform float opacityValue;
varying float vDistance;
varying vec3 vPosition;

void main() {
    // Flowing energy waves along connections
    float wave1 = sin(vDistance * 12.0 + time * 6.0 * entangleStrength);
    float wave2 = cos(vDistance * 8.0 + time * 4.0 * entangleStrength + 1.57);
    
    float combinedWave = (wave1 + wave2) * 0.5;
    float glow = pow(abs(combinedWave), 4.0) * 0.8;
    
    // Color shifting based on entanglement
    vec3 baseColor = mix(color1, color2, glow);
    vec3 pulseColor = mix(baseColor, vec3(1.0, 1.0, 1.0), glow * 0.3);
    
    float alpha = opacityValue + glow * 0.7;
    gl_FragColor = vec4(pulseColor * (2.0 + glow), alpha);
}
</script>

<style>
html, body {
    margin: 0; padding: 0; overflow: hidden;
    background: radial-gradient(ellipse at center, #050f19 0%, #000000 100%);
    font-family: 'Courier New', monospace;
    color: #40e0d0;
    user-select: none;
}

#canvas3d {
    position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
    display: block;
    cursor: crosshair;
}

#ui-overlay {
    position: fixed; top: 15px; left: 15px; right: 15px; z-index: 9999;
    display: flex; flex-wrap: wrap; gap: 10px;
    background: rgba(5,15,25,0.92);
    border-radius: 15px;
    padding: 15px;
    box-shadow: 0 0 30px rgba(64, 224, 208, 0.6);
    border: 1px solid rgba(64, 224, 208, 0.3);
    max-width: calc(100vw - 30px);
    backdrop-filter: blur(10px);
}

.control-btn, .input-label {
    background: linear-gradient(135deg, #004466 0%, #006688 100%);
    border: 1px solid #40e0d0;
    color: #e0f8ff;
    padding: 12px 18px;
    border-radius: 20px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    user-select: none;
    font-size: 14px;
}

.control-btn:hover, .input-label:hover {
    background: linear-gradient(135deg, #40e0d0 0%, #20b2aa 100%);
    color: #001122;
    box-shadow: 0 0 20px #40e0d0;
    transform: translateY(-2px);
}

.control-btn.active {
    background: linear-gradient(135deg, #40e0d0 0%, #20b2aa 100%);
    color: #001122;
    box-shadow: 0 0 15px #40e0d0;
}

.input-label {
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 160px;
}

.input-label span {
    margin-bottom: 5px;
    font-size: 12px;
    opacity: 0.9;
}

input[type=range] {
    -webkit-appearance: none;
    width: 100%;
    height: 6px;
    background: linear-gradient(90deg, #001122 0%, #003344 100%);
    border-radius: 10px;
    outline: none;
    cursor: pointer;
}

input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    background: #40e0d0;
    border-radius: 50%;
    box-shadow: 0 0 15px #40e0d0;
    transition: all 0.2s ease;
}

input[type=range]::-webkit-slider-thumb:hover {
    transform: scale(1.2);
    box-shadow: 0 0 20px #40e0d0;
}

#status-display {
    position: fixed; bottom: 15px; left: 15px; z-index: 9999;
    background: rgba(5, 15, 25, 0.92);
    padding: 10px 15px; 
    border-radius: 12px; 
    border: 1px solid #40e0d0;
    font-size: 12px; 
    pointer-events: none;
    backdrop-filter: blur(5px);
    box-shadow: 0 0 20px rgba(64, 224, 208, 0.4);
}

.frequency-btn {
    background: linear-gradient(135deg, #145a32 0%, #1a5276 100%);
    border: 1px solid #40e0d0;
}

.frequency-btn.active {
    background: linear-gradient(135deg, #40e0d0 0%, #20b2aa 100%);
    color: #001122;
}
</style>
</head>
<body>

<canvas id="canvas3d"></canvas>

<div id="ui-overlay">
    <button id="btnToggleAnimation" class="control-btn active">⏸️ Pause</button>
    <button id="btnRegenerate" class="control-btn">🌀 Regenerate</button>
    
    <label class="input-label">
        <span>Fractal Depth</span>
        <input type="range" id="fractalDepthRange" min="1" max="7" value="4">
    </label>
    
    <label class="input-label">
        <span>Entanglement</span>
        <input type="range" id="entangleStrengthRange" min="0.5" max="5" step="0.1" value="2.0">
    </label>
    
    <label class="input-label">
        <span>Resonance</span>
        <input type="range" id="resonanceRange" min="0.1" max="3" step="0.1" value="1.0">
    </label>
    
    <button id="btnToggleAudio" class="control-btn">🔇 Audio Off</button>
    
    <button id="btnSolfeggio" class="control-btn frequency-btn">🎵 528Hz</button>
    <button id="btnQuantum" class="control-btn frequency-btn">🌌 432Hz</button>
    <button id="btnCosmic" class="control-btn frequency-btn">✨ 639Hz</button>
</div>

<div id="status-display">
    Status: <span id="currentStatus">Initializing Quantum Matrix...</span> | 
    Energy: <span id="energyDisplay">0.00</span> | 
    Nodes: <span id="nodeCount">0</span>
</div>

<script>
// QUANTUM RESONANCE ENGINE v2.0
let scene, camera, renderer, composer;
let latticeGroup;
let latticePoints = [];
let connections = [];
let isAnimating = true;
let time = 0;
let globalAudioEnergy = 0.5;
let currentResonance = 1.0;

// Sacred Frequency System
const sacredFrequencies = {
    solfeggio: [174, 285, 396, 417, 528, 639, 741, 852, 963],
    quantum: [111, 222, 333, 444, 555, 666, 777, 888, 999],
    cosmic: [432, 864, 1296]
};

let currentFrequencySet = 'solfeggio';
let activeOscillators = [];

// Web Audio
let audioContext = null;
let analyser, freqDataArray;

// UI Elements
const statusDisplay = document.getElementById('currentStatus');
const energyDisplay = document.getElementById('energyDisplay');
const nodeCountDisplay = document.getElementById('nodeCount');

const themes = {
    bg: 0x050f19,
    primary: 0x1a5276,
    secondary: 0x145a32,
    accent: 0x40e0d0,
    glow: 0x8ae2ff,
};

// Enhanced Node Creation with Sacred Geometry
function createNode(x, y, z, depth, index) {
    const geometry = new THREE.SphereGeometry(0.1 + depth * 0.02, 20, 20);
    const material = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0.0 },
            audioEnergy: { value: 0.5 },
            resonance: { value: 1.0 },
            color: { value: new THREE.Color(themes.accent) }
        },
        vertexShader: document.getElementById('nodeVertexShader').textContent,
        fragmentShader: document.getElementById('nodeFragmentShader').textContent,
        transparent: true,
        blending: THREE.AdditiveBlending,
    });

    const node = new THREE.Mesh(geometry, material);
    node.position.set(x, y, z);
    node.userData = { 
        depth, 
        index, 
        energy: 0.8 + Math.random() * 0.4,
        spin: Math.random() * Math.PI * 2,
        frequency: sacredFrequencies[currentFrequencySet][depth % sacredFrequencies[currentFrequencySet].length]
    };
    
    latticeGroup.add(node);
    latticePoints.push(node);
    return node;
}

// Flower of Life Inspired Pattern
function generateSacredLattice(center, radius, depth, maxDepth) {
    if (depth <= 0 || latticePoints.length > 800) return;

    const layers = 2 + depth;
    const goldenRatio = 1.618;
    
    for (let layer = 0; layer < layers; layer++) {
        const layerRadius = radius * (0.3 + layer * 0.4);
        const nodesInLayer = Math.floor(6 * goldenRatio * (layer + 1));
        
        for (let i = 0; i < nodesInLayer; i++) {
            const angle = (i / nodesInLayer) * Math.PI * 2;
            const spiralOffset = depth * 0.3;
            
            const x = center.x + Math.cos(angle + spiralOffset) * layerRadius;
            const y = center.y + Math.sin(angle + spiralOffset) * layerRadius;
            const z = center.z + Math.cos(angle * goldenRatio) * 0.2 * radius;
            
            createNode(x, y, z, depth, latticePoints.length);
            
            // Recursive branching with golden ratio spacing
            if (depth > 1 && Math.random() > 0.6) {
                const branchDirection = new THREE.Vector3(
                    Math.cos(angle * 2),
                    Math.sin(angle * 2),
                    Math.cos(angle)
                ).normalize();
                
                const newCenter = new THREE.Vector3(x, y, z).add(branchDirection.multiplyScalar(radius * 0.3));
                generateSacredLattice(newCenter, radius * 0.6, depth - 1, maxDepth);
            }
        }
    }
}

function clearLattice() {
    while(latticeGroup.children.length > 0) {
        latticeGroup.remove(latticeGroup.children[0]);
    }
    latticePoints = [];
    connections = [];
}

function createConnections(strength) {
    connections.forEach(conn => latticeGroup.remove(conn));
    connections = [];
    
    const connectionThreshold = 2.0 + strength * 0.5;
    
    for (let i = 0; i < latticePoints.length; i++) {
        for (let j = i + 1; j < latticePoints.length; j++) {
            const dist = latticePoints[i].position.distanceTo(latticePoints[j].position);
            if (dist < connectionThreshold) {
                const opacity = THREE.MathUtils.clamp(0.1 + (0.6 / dist), 0.1, 0.9);
                
                const geometry = new THREE.BufferGeometry().setFromPoints([
                    latticePoints[i].position,
                    latticePoints[j].position
                ]);
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        color1: { value: new THREE.Color(themes.secondary) },
                        color2: { value: new THREE.Color(themes.accent) },
                        entangleStrength: { value: strength },
                        opacityValue: { value: opacity }
                    },
                    vertexShader: document.getElementById('lineVertexShader').textContent,
                    fragmentShader: document.getElementById('lineFragmentShader').textContent,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    linewidth: 1
                });

                const line = new THREE.Line(geometry, material);
                latticeGroup.add(line);
                connections.push(line);
                
                // Limit connections for performance
                if (connections.length > 2000) return;
            }
        }
    }
}

function regenerate() {
    clearLattice();
    const depth = parseInt(document.getElementById('fractalDepthRange').value);
    const strength = parseFloat(document.getElementById('entangleStrengthRange').value);
    
    generateSacredLattice(new THREE.Vector3(0, 0, 0), 3.0, depth, depth);
    createConnections(strength);
    
    nodeCountDisplay.textContent = latticePoints.length;
    updateStatus(`🌀 Sacred Lattice Generated: ${latticePoints.length} Nodes`);
}

// Enhanced Audio System with Sacred Frequencies
function setupAudio() {
    if (audioContext) return;
    
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 512;
    freqDataArray = new Uint8Array(analyser.frequencyBinCount);
    
    createFrequencyOscillators();
    
    document.getElementById('btnToggleAudio').textContent = '🔊 Audio On';
    document.getElementById('btnToggleAudio').classList.add('active');
    updateStatus('Sacred Frequencies Activated');
}

function createFrequencyOscillators() {
    // Clear existing oscillators
    activeOscillators.forEach(osc => {
        osc.stop();
        osc.disconnect();
    });
    activeOscillators = [];
    
    const frequencies = sacredFrequencies[currentFrequencySet].slice(0, 3);
    
    frequencies.forEach(freq => {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.type = 'sine';
        oscillator.frequency.value = freq;
        gainNode.gain.value = 0.1;
        
        oscillator.connect(gainNode);
        gainNode.connect(analyser);
        analyser.connect(audioContext.destination);
        
        oscillator.start();
        activeOscillators.push(oscillator);
    });
}

function toggleAudio() {
    if (audioContext) {
        audioContext.close();
        audioContext = null;
        activeOscillators = [];
        document.getElementById('btnToggleAudio').textContent = '🔇 Audio Off';
        document.getElementById('btnToggleAudio').classList.remove('active');
        globalAudioEnergy = 0.3;
        updateStatus('Audio System Silent');
    } else {
        setupAudio();
    }
}

function setFrequencySet(setName) {
    currentFrequencySet = setName;
    document.querySelectorAll('.frequency-btn').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
    
    if (audioContext) {
        createFrequencyOscillators();
    }
    
    updateStatus(`Frequency Set: ${setName.toUpperCase()}`);
}

function updateStatus(message) {
    statusDisplay.textContent = message;
    console.log(`Quantum Engine: ${message}`);
}

function setupControls() {
    document.getElementById('btnToggleAnimation').onclick = function() {
        isAnimating = !isAnimating;
        this.textContent = isAnimating ? '⏸️ Pause' : '▶️ Play';
        this.classList.toggle('active', isAnimating);
    };
    
    document.getElementById('btnRegenerate').onclick = regenerate;
    document.getElementById('btnToggleAudio').onclick = toggleAudio;
    
    document.getElementById('fractalDepthRange').oninput = regenerate;
    document.getElementById('entangleStrengthRange').oninput = function() {
        createConnections(parseFloat(this.value));
    };
    
    document.getElementById('resonanceRange').oninput = function() {
        currentResonance = parseFloat(this.value);
    };
    
    document.getElementById('btnSolfeggio').onclick = () => setFrequencySet('solfeggio');
    document.getElementById('btnQuantum').onclick = () => setFrequencySet('quantum');
    document.getElementById('btnCosmic').onclick = () => setFrequencySet('cosmic');
}

function initThreeJS() {
    const canvas = document.getElementById('canvas3d');
    
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.z = 12;

    renderer = new THREE.WebGLRenderer({ 
        canvas, 
        antialias: true, 
        alpha: true,
        powerPreference: "high-performance"
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(themes.bg, 1);

    latticeGroup = new THREE.Group();
    scene.add(latticeGroup);

    // Post-processing with enhanced bloom
    const renderScene = new THREE.RenderPass(scene, camera);
    const bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        2.0,  // strength
        0.4,  // radius
        0.85  // threshold
    );

    composer = new THREE.EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    setupControls();
    regenerate();

    window.addEventListener('resize', function() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });

    updateStatus('🌟 Quantum Resonance Engine Active');
    animate();
}

function animate() {
    requestAnimationFrame(animate);
    
    time += 0.016;

    if (isAnimating) {
        // Audio energy analysis
        if (analyser && audioContext) {
            analyser.getByteFrequencyData(freqDataArray);
            let energySum = 0;
            for (let i = 0; i < 40; i++) energySum += freqDataArray[i];
            globalAudioEnergy = THREE.MathUtils.lerp(globalAudioEnergy, (energySum / 40) / 255, 0.1);
        }

        energyDisplay.textContent = globalAudioEnergy.toFixed(3);

        // Animate lattice
        latticeGroup.rotation.y += 0.002 * currentResonance;
        latticeGroup.rotation.x = Math.sin(time * 0.1) * 0.1;

        // Update shader uniforms
        latticePoints.forEach((node, index) => {
            node.material.uniforms.time.value = time + index * 0.01;
            node.material.uniforms.audioEnergy.value = globalAudioEnergy;
            node.material.uniforms.resonance.value = currentResonance;
            
            // Gentle floating motion
            node.position.y += Math.sin(time * 0.5 + index) * 0.002 * currentResonance;
        });

        connections.forEach(conn => {
            conn.material.uniforms.time.value = time;
            conn.material.uniforms.entangleStrength.value = 
                parseFloat(document.getElementById('entangleStrengthRange').value);
        });
    }

    composer.render();
}

// Initialize the Quantum Engine
initThreeJS();
</script>

</body>
</html>
